var store = [{
        "title": "Secret Life of A DNS Query",
        "excerpt":"This article describes how a DNS query gets resolved. Though a website is loaded in just one-click on our devices, a lot of work goes on at the back end to render that webpage. Let’s see how it’s done.   Before you read further, these are the terms you need to get acquainted with:  Important Terms:   IP Address   An IP address is a unique address that identifies a device on the internet or a local network.   Query   A query is a message sent by the client to the server.   Cache   Computing component that transparently stores data so that future requests for that data can be served faster.   DNS - the Internet’s Directory Service   The browser needs to translate “www.blogger.com” to its corresponding IP address, because hostnames can consist of variable-length alphanumeric characters, they would be difficult to process by routers. For these reasons, hosts are also identified by so-called IP addresses.   DNS Resolver   Servers designed to receive DNS queries from web browsers and other applications.   Authoritative Name Servers   Servers where the DNS records are stored. Consists of root name servers, TLD servers and authoritative servers.      Interaction of DNS Servers:     Consider you click on the URL www.blogger.com           Browser first checks if IP address is present in its DNS cache, if not it calls the function present in the operating system to do DNS lookups. For E.g. on Linux that function is getaddrinfo.            The OS might also have a DNS cache, if it has, then the function first checks if IP address is present in this cache. If IP is still not found, the function sends request to a server called DNS resolver            The resolver checks if IP address is present in its cache, if not it contacts the root name server.            The root name server checks if IP is present in its cache, if yes, it sends the corresponding IP address, if not it replies with “I don’t know this name but ask the TLD server.”            The resolver then asks/queries the TLD server.            The TLD server checks if IP is present in its cache, if yes, it sends the corresponding IP address, if not it replies with “I don’t know this name but ask the Authoritative name server.”            The resolver then queries the authoritative name server.            The authoritative name server has the IP Address of the requested website in its database. It responds with the corresponding IP to the resolver.            The resolver/local DNS server then sends this IP to the OS.            This IP is communicated to the browser and it starts opening a TCP connection to the server.       As shown above, the DNS query is iterative in nature, as recursive queries put heavy load of name resolution in upper levels of hierarchy.    References:   James Kurose, Keith Ross, Computer Networking A Top-Down Approach, 7th Edition.  ","categories": ["networking"],
        "tags": ["networks","DNS"],
        "url": "/networking/secret-life-of-a-dns-query/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Creating Processes",
        "excerpt":"In this article I have tried to explain the important things that happen during a process creation. I always had doubts about     How a process is created in OS ?   From where does it all start ?   What happens when you start a process ?   What exactly is fork and exec ?   Let us see.   Process Heirarchy   Every process in Linux lives in a “process tree”. You can see that tree by running pstree in terminal. The root of the tree is init, with PID 1. Every process (except init) has a parent, and any process has many children.   Fork() System Call   The fork() system call is used to create a new process.The new process created by fork is called the child process.This function is called once but returns twice. The only difference in the returns is that the return value in the child is 0, whereas the return value in the parent is the process ID of the new child.The child - the process that is created is an (almost) exact copy of the calling process.   Exec() System Call  (Load into memory and then execute)   Fork creates a new process which is a clone of itself, but what if we want to change the course of the process? Then we use exec() syscall. Exec() replaces the current process — its text, data, heap, and stack segments — with a brand-new program from disk.   On Boot Up   On boot the kernel starts the init process, which then forks and execs the systems boot scripts. These fork and exec more programs, eventually ending up forking a login process.This is also known as process spawning which is carried out by these two systemcalls [fork &amp; exec] in the background.     Example code snippet of fork() and exec() in a C program:   int pid = fork(); // now I am split in two! aaaaugh! // who am I? I could be either the child or the parent if (pid == 0) {     // ok I am the child process     // ls will take over and I will be a totally different process      exec([\"ls\"]) } else if (pid == -1) {     // omg fork failed -- this is a disaster :( } else {     // ok i am the parent     // continue my business being a cool program     // I could wait for the child to finish if I want }    Now, if I want to start a process called ls to list all the files in a directory. The process starts out like this:   my parent      |- me   When I run fork(), a child is created which is a clone of myself.   my parent      |- me           |-- clone of me  Then my clone calls exec() that is, my child runs exec(\"ls\"). That leaves us with   my parent      |- me           |-- ls  Once ls exits I will be all alone by myself.(Almost)   my parent      |- me           |-- ls(zombie)  At this point ls is actually a zombie process! That means it’s dead, but it’s waiting around for the parent in case the parent wants to check on its (child’s) return value (using the wait system call.) Once I get its return value, I will really be all alone again.   my parent      |- me     The following paragraph from Operating Systems:Three Easy Pieces sums up the gist of the article:      The fork() system call is strange; its partner in crime, exec(), is not so normal either. What it does: given the name of an executable (e.g., wc), and some arguments (e.g., p3.c), it loads code (and static data) from that executable and overwrites its current code segment (and current static data) with it; the heap and stack and other parts of the memory space of the program are re-initialized. Then the OS simply runs that program, passing in any arguments as the argv of that process. Thus, it does not create a new process; rather, it transforms the currently running program (formerly p3) into a different running program (wc). After the exec() in the child, it is almost as if p3.c never ran; a successful call to exec() never returns.      References:   Remzi H. Arpaci-Dusseau_ Andrea C Arpaci-Dusseau - Operating Systems- Three Easy Pieces   Got this awesome concept from Julia Evans blog  ","categories": ["operating systems"],
        "tags": ["os","fork","process creation"],
        "url": "/operating%20systems/process-creation/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Debugging 101 - Love Your Bugs",
        "excerpt":"Errors and bugs are a necessary evil in any software developement field, and learning the art of debugging is a very vital step if you want to:      Improve your developer productivity   Write reliable code   In this article I have tried to document all the debugging methods that I learnt while working on my projects.      Whenever you encounter a bug in any of your code/installation it is always helpful to remember the following things:     The error happens for a logical reason - its never magic   Be confident that you can fix it   Being stuck is temporary   Now that you have these 3 things in your toolkit let us proceed for some debugging steps so that you can feel your inherent superpower. :)   Step 1: Read error message carefully   Error messages usually contain a lot of information about what went wrong. But they sometimes can be very large and overwhelming to read. You can  use these tricks to extract the necessary information from them:     Start fixing the first error message in case of multiple error messages. Fixing the first one often fixes the remaining errors   Search if any solution is available on the internet for the error   Step 2: Brainstorm possible reasons for the error   Now here I won’t be able to give exact reasons but some examples may include:     Is there something wrong with the server?   Am I using correct package version?   Have I followed all the instructions?(In case of errors in installations)   After finding possible reasons try to narrow it down to the most possible reason, also draw a diagram of the process if possible   Step 3: Investigate      Read the documentation (Important)   Add lots of print statements   Use a debugger   Look at logs   A meme that highlights the importance of reading the docs:      Step 4: Make complex things simple      Fix one problem at a time   Write clean code   Reduce randomness   Shorten your feedback/output loop (when you need to run the code many times)   Step 5: This also helps      Take a break   Ask a friend   Explain the error/bug out loud   Finding tools that make debugging easier - eg. debuggers, profilers, tracers, fuzzers, etc   Step 6: After fixing the bug     Celebrate - dance a little   Tell somebody what you learnt - that way you won’t forget it   Document your bug    Debugging can be an interesting adventure.   I would like to end this article by quoting Edsger Dijkstra:     ” Program testing can be used to show the presence of bugs, but never to show their absence! “   ","categories": ["tech-views"],
        "tags": ["bugs","debugging"],
        "url": "/tech-views/debugging_guide/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Deploy a Python Server with Flask on Windows Apache Server",
        "excerpt":"Recently I programmed a TLS/SSL checker web app - which checks which tls protocol a website is using and also gives a list of SSL vulnerablities the website is prone to. I programmed this script in python using flask framework and now I wanted to deploy it to the server. But little did I know that deploying or setting up a python server with flask can be tricky especially on a apache server.   So, these are my learnings and some useful links - you can read them so that you can finish deploying a python server on Windows apache faster than me ! :)   Prerequisites:     Python - can be downloaded from  https://www.python.org/downloads/   Flask - can be installed by typing the following command in cmd     $ pip install flask           WfastCGI module - installed by typing the following command in cmd     $ pip install wfastcgi                Deploying using Windows IIS Server:           I have used this link to install until step IV (As given in the article) with some changes. CGI module will be found in  Server Roles &gt; Web Server(IIS) &gt; Web Server &gt; Application Development &gt; CGI   (If it is not found at the exact location as given in the above article)            After completing all steps – if you get internal server error when you access the website url - you can refer these steps: reference  Error an unknown FastCGI error occurred               To deploy it on port eg say :4000:             Go to IIS Manager       In sites dropdown select the TLS checker website       Select edit site &gt; Bindings       Select https &gt; edit &gt;       Enter port 4000       Add hostname       You may have to open the port 4000 in inbound firewall rules               Deploying using WAMP Server :      This article is very apt but I might go into more details about this installation in coming weeks. https://thilinamad.medium.com/flask-app-deployment-in-windows-apache-server-mod-wsgi-82e1cfeeb2ed      Thank - You for reading !         Avani       ","categories": ["tech-views"],
        "tags": ["installation","flask"],
        "url": "/tech-views/Ways-to-deploy-a-python-server-on-apache/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "The TCP/IP Model and Security",
        "excerpt":"The TCP/IP (Transmission Control Protocol/Internet Protocol) reference model defines how information moves from sender to receiver. TCP/IP was not originally designed with security, so we must secure the network using many external methods.  Many protocols are designed to secure network traffic at various levels. The choice of where to implement security in the stack depends on the application’s and user’s requirements. Regardless of where security is applied in the stack, it must provide the following fundamental services to the user:     Key management   Confidentiality   Nonrepudiation   Integrity / Authentication   Authorization   The security measures implemented at different layers of the stack can offer varying services. In some instances, it is beneficial to assign certain capabilities to one layer while allocating others to a different layer. This blog explores the benefits and nuances of providing security at various levels within the TCP/IP stack.      Security at the Application Layer  The application layer connects applications to the underlying network for message transmission. Host-to-host communication occurs at the application layer, so security has to be implemented in end hosts. Applications should design their security mechanisms when their specific needs cannot be met by the lower layers. One example of this is non-repudiation. The lower layers struggle to provide non-repudiation services because they do not have access to the data. Some examples of the security mechanisms implemented at the applicaion layer include  PGP, Kerberos, and Secure Shell.  Benefits     Executing in the context of the user enables easy access to user credentials such as private keys.   Ensures complete access to the data the user aims to protect, making it easier to offer services like non-repudiation.   An application can be extended without relying on the operating system to provide these services.   Key Considerations     Security mechanisms have to be designed independently for each application, so there is a greater probability of making mistakes and hence opening up security holes for attacks.   Security at the Transport Layer  The transport layer is responsible for logical communications between applications running on different hosts. Adding security at the transport layer does not need enhancements in each application. TLS (Transport Layer Security) protocol is implemented in the transport layer which provides security services such as authentication, integrity, and confidentiality on top of TCP. (TLS is not implemented over UDP as it needs to maintain context for a connection)  Benefits     It bundles authentication with encryption.   Easy to install and execute.   It reinforces the integrity of the communication.   The TLS protocol allows client and server applications to detect message tampering, message interception and message forgery.   Key Considerations     Obtaining the user context is complicated.   TLS can only be implemented on an end system.   Applications need modification to request security services from the transport layer.   Security at the Network Layer  The network layer is concerned with addressing and routing packets from the source to the destination. It is the lowest layer in the OSI model that deals with end-to-end transmission. Implementing security at this layer has many advantages.  Benefits     Decreased overheads of key negotiations.   If security implemented at the network and lower levels, fewer applications need changes.   Ability to build VPNs and intranets which are subnet based, and network layer supports subnet-based security.   IPSec, the protocol that can secure all and any kind of Internet traffic operates at the network level. IPSec also allows per flow or per connection security and thus allows for very fine-grained security control.     Key Considerations       Difficulty in handling issues such as non - repudiation of data. [As discussed above, this is better handled in higher layers]   Difficult to exercise control on a per user basis on a multiuser machine when security is implemented at network layer.   Security at the Link Layer  The Data Link layer is responsible for communications between end-device network interface cards. This layer encapsulates network packets into frames and also performs error detection. If a dedicated link between two hosts or routers is present, then traffic needs encryption to prevent snooping, here hardware encryption devices can be used. For devices connected to IP networks, security at the data link layer is insufficient; one must move up a layer to provide adequate security services.  Benefits     Speedy and fast to implement because of hardware encryption devices   Key Considerations     Not scalable   This works well only on dedicated links – for e.g. ATM machines   The two entities involved in communication have to be physically connected.   References     Doraswamy, N. and Harkins, D. (1999) IPSec: The New Security Standard for the internet, intranets, and Virtual Private Networks. Upper Saddle River, NJ: Prentice Hall.    What is TLS    ","categories": ["networking"],
        "tags": ["networks","tls","security","tcp/ip"],
        "url": "/networking/the-tcp-ip-and-security/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Node Js and React Js Web App: An Overview",
        "excerpt":"During my summer internship, I was tasked with building a full-stack web application to meet the company’s needs. The technology was completely new to me, so it took quite a bit of time to understand how the different components—Node.js for the backend, React for the frontend, and a database—fit together. In this blog, I will explain the general structure of a Node-React full-stack application wrt programming perspective.      ℹ️ Note:  This is a beginner’s guide, and the structure outlined here will be used in the development environment.  To deploy the application to production, several changes need to be made, including modifications to the backend .env file and converting the React frontend to static JavaScript files. I plan to cover more details on this in my upcoming blogs.     Components of a Full Stack Web App     Frontend Development            It is the visible part of a website responsible for user experience.       Responsible for user interaction.       Calls the backend api.           Backend Development            It involves the server-side development of websites, focusing primarily on their functionality.       Responsible for managing the database through queries and APIs based on client-side commands.           Database            An organized collection of related data that enables efficient retrieval, insertion, and deletion of information.               As shown in the picture, this illustrates the flow of a query from the frontend to the backend and to the database, then back.   Points to Note     It is considered best practice to separate the client-side frontend code from the server-side backend code by organizing them into distinct folders.   If you are using a Node-React technology stack, it’s important to note that the backend routes and frontend routes are different.   During the development of your web application, you will need to run the React development server on a specific port, such as 3000, while the Node server should be started on a different port, like 5000. This setup allows the front end to send requests to the appropriate REST API (back-end route) to perform functions or fetch data. (PS: in the PROD environment, the frontend and the backend are bundled up to use a single port)   If you are using MySQL or a similar relational database, the Node.js server will typically query the data on the default port 3306. However, if you wish to change this default port, you can specify the new port in the environment variables. (More details on this will be covered in a future blog post.)   The ports really confused me in the beginning, but once the WHY and HOW of things is clear, everything becomes a piece of cake. This was a brief overview of the structure of a full stack application. I plan to write more blogs about this particular setup, so stay tuned! 😊  ","categories": ["full-stack"],
        "tags": ["node js","react","web app"],
        "url": "/full-stack/a-node-js-web-app-an-overview/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Node Production Headache: Security Headers",
        "excerpt":"Introduction   Hearing the term “security headers” might be intimidating for someone new to computer science, especially in the field of web development. Security headers are HTTP response headers that provide essential security measures that your application can use to enhance its overall security. These headers play a critical role in ensuring the safety of a website.   The following table outlines some of the most important security headers.   Common Security Headers                  Security Header       Expected Value       Use                       Content-Security-Policy       default-src ‘self’;       Restricts sources for content to mitigate cross-site scripting (XSS) and data injection.                 Cross-Origin-Opener-Policy       same-origin       Isolates browsing contexts to prevent cross-origin information leaks.                 Cross-Origin-Resource-Policy       same-origin       Limits the sharing of resources to the same origin.                 Origin-Agent-Cluster       ?1       Changes process isolation to be origin-based for improved security.                 Referrer-Policy       no-referrer or strict-origin       Controls how much referrer information is included with requests.                 Strict-Transport-Security       max-age=31536000; includeSubDomains       Enforces HTTPS for all connections and prevents downgrade attacks.                 X-Content-Type-Options       nosniff       Prevents the browser from MIME-sniffing a response away from the declared content-type.                 X-DNS-Prefetch-Control       on or off       Controls DNS prefetching to reduce potential information leaks.                 X-Download-Options       noopen       Forces downloads to be saved instead of auto-executed (Internet Explorer only).                 X-Frame-Options       DENY or SAMEORIGIN       Prevents the webpage from being framed to protect against clickjacking attacks.                 X-Permitted-Cross-Domain-Policies       none or master-only       Controls cross-domain behavior for Adobe products, like Acrobat.                 X-Powered-By       (Header removed entirely)       Prevents revealing server information to mitigate potential attacks.                 X-XSS-Protection       0       Disables buggy XSS filters in older browsers to avoid unintended issues.                 Permissions-Policy       geolocation=(), microphone=()       Restricts access to browser features like geolocation and microphone.                 Expect-CT       enforce, max-age=86400       Ensures that valid Certificate Transparency information is included for HTTPS.                 Cross-Origin-Embedder-Policy       require-corp       Mitigates cross-origin attacks for resources embedded in the page.                 Cache-Control       no-store, no-cache, must-revalidate       Prevents sensitive information from being stored in the cache.                 Set-Cookie       Secure; HttpOnly; SameSite=Strict       Protects cookies by making them secure, accessible only to HTTP, and tied to the same site.           When building a web application, the developer must set these response headers in the code.   How to Set Security Headers   Let’s consider an example in Node.js. We can set security headers either manually or by using a popular library called ‘helmet’, which acts as middleware to automatically set these headers for you. Using a library like helmet is convenient, so we’ll focus on its implementation. First, we will look at how to use helmet in your code, and then we will discuss the importance of carefully setting security headers when deploying to production.      Install Helmet using this command   $ npm install helmet      Call the helmet middleware in your application’s main file for e.g index.js or app.js   import helmet from \"helmet\";  const app = express();  app.use(helmet());   You can learn more about the default headers set by the Helmet.js by reading here.      If you want to customize the default headers set by Helmet, you can do so. It is essential to customize the headers because relying solely on the default headers provided by Helmet in a production environment can hinder the functionality of your application. Why is this the case ? Let’s discuss it in the next section.   Security Headers and Production Environment   After coding my Node.js application, I was ready to deploy it in production. I initially thought that the deployment process would go faster since I had already simulated it on my virtual machine, but I was mistaken. If you noticed, I mentioned “headache” in the title of this blog for a reason.   When I simulated the production environment on my virtual machine - it was set up on localhost, also the microsoft login was not set during that time.   When I deployed the application in production on my domain - the following issues were encountered over a span of one week      I encountered an issue where the Microsoft login popup was not appearing. After changing the popup setting to redirect, it directed me to the Microsoft Login page. However, after entering the correct login credentials, I ended up with a blank page.            This happened because the Content Security Policy (CSP) was not configured to allow requests from the Microsoft website. The login popup was not appearing because the frameAncestors and frameSrc in the CSP was not configured for “https://login.microsoftonline.com”       To resolve this, I updated the connectSrc, frameSrc, frameAncestors in the CSP to include not only the “self” variable but also all the domains from which we expected to receive requests.         app.use( helmet({  contentSecurityPolicy: {  directives: {    defaultSrc: [\"'self'\"],    connectSrc: [      \"'self'\",      \"https://login.microsoftonline.com\",      \"https://graph.microsoft.com\",      \"https://mydomain.com\",      \"https://somethirdpartydomain.com\",    ],    frameSrc: [      \"'self'\",      \"https://login.microsoftonline.com\",      \"https://mydomain.com\",      \"blob:\",    ], // for tokens    frameAncestors: [      \"'self'\",      \"https://login.microsoftonline.com\",      \"https://mydomain.com\",    ], // Allows embedding in Azure AD frames/popups  },  }, }) );                           After the above three changes, I was able to login, but still faced problems. Half of my stylesheet, scripts and images were not present and the pop ups were not showing small elements like a cross svg etc.            To resolve that, I updated the scriptSrc, imgSrc and styleSrc in the CSP directives.           app.use( helmet({  contentSecurityPolicy: {  directives: {    defaultSrc: [\"'self'\"],    connectSrc: [      \"'self'\",      \"https://login.microsoftonline.com\",      \"https://graph.microsoft.com\",      \"https://mydomain.com\",      \"https://somethirdpartydomain.com\",    ],    frameSrc: [      \"'self'\",      \"https://login.microsoftonline.com\",      \"https://mydomain.com\",      \"blob:\",    ], // for tokens    frameAncestors: [      \"'self'\",      \"https://login.microsoftonline.com\",      \"https://mydomain.com\",    ], // Allows embedding in Azure AD frames/popups    scriptSrc: [      \"'self'\",      \"https://login.microsoftonline.com\",      \"https://mydomain.com\",    ],    imgSrc: [\"'self'\", \"blob:\", \"data:\"],    styleSrc: [\"'self'\", \"'unsafe-inline'\", \"https://mydomain.com\"], // Allows inline styles  },  }, }) );                           The following is some of the security header configuration I used to deploy my application to production. Additionally, we need to implement CORS (Cross-Origin Resource Sharing), which is not included in Helmet. CORS can be quite tricky, so I will save that topic for another post. Thank you for reading until the end!  import helmet from \"helmet\";  const app = express();  app.use(   helmet({     contentSecurityPolicy: {       directives: {         defaultSrc: [\"'self'\"],         connectSrc: [           \"'self'\",           \"https://login.microsoftonline.com\",           \"https://graph.microsoft.com\",           \"https://mydomain.com\",           \"https://somethirdpartydomain.com\",         ],         frameSrc: [           \"'self'\",           \"https://login.microsoftonline.com\",           \"https://mydomain.com\",           \"blob:\",         ], // for tokens         frameAncestors: [           \"'self'\",           \"https://login.microsoftonline.com\",           \"https://mydomain.com\",         ], // Allows embedding in Azure AD frames/popups         scriptSrc: [           \"'self'\",           \"https://login.microsoftonline.com\",           \"https://mydomain.com\",         ],         imgSrc: [\"'self'\", \"blob:\", \"data:\"],         styleSrc: [\"'self'\", \"'unsafe-inline'\", \"https://mydomain.com\"], // Allows inline styles       },     },     crossOriginOpenerPolicy: { policy: \"same-origin\" },     crossOriginResourcePolicy: { policy: \"same-origin\" },     originAgentCluster: true,     referrerPolicy: { policy: \"no-referrer\" },     hsts: {       maxAge: 31536000, //  HSTS policy remains in effect for one year       includeSubDomains: true,       preload: true,     },     noSniff: true,     dnsPrefetchControl: { allow: false },     frameguard: { action: \"sameorigin\" },     permittedCrossDomainPolicies: { permittedPolicies: \"none\" },   }) );  ","categories": ["full-stack"],
        "tags": ["node js","security headers","web app","helmet","production"],
        "url": "/full-stack/node-and-security-headers/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Bending Time",
        "excerpt":"What is a minute, really? Google would say it is 60 seconds. But do we perceive those 60 seconds the same way each time?  Check out these activities that can help you either slow down or speed up your perception of a minute. Feel free to share any other interesting examples you might have!   Slowing a Minute      Try holding a squat or L-sit for 60 seconds.   Try holding your breath for 60 seconds.   After asking a question to a group of people wait for 60 seconds before you answer.   Sprint at full speed for 60 secs.   Attend a lecture of the topic you find boring.   Speeding up a Minute     Try to write an answer that takes 10 minutes in 60 seconds during a test.   Spend time with your loved one.   Watch reels on Instagram   Take a 60 seconds nap.   Try to come up with a solution for a leetcode medium question in 60 seconds.    ","categories": ["miscellaneous"],
        "tags": ["time","minute"],
        "url": "/miscellaneous/bending-time/",
        "teaser": "/assets/images/teaser.jpg"
      },{
    "title": "About",
    "excerpt":"   A personal collection of insights and lessons I have gained throughout my academic journey.    Hello ! I am Avani, a curious Information Technology student with a keen interest in fascinating tech concepts. My plan is to upload all the interesting things I discover here, including my projects, explanations of various concepts, and helpful installation guides. I’m also looking to collaborate on open-source projects, so feel free to connect with me!   I invite you to dive into a vibrant collection of the most intriguing tech projects, ideas, and experiments from the world of software development and beyond. This blog is a sandbox for the curious and creative — whether you’re a developer seeking inspiration, a tech enthusiast exploring trends, or just someone fascinated by the intersection of code and creativity.   Thank you for visiting my website.  ","url": "http://localhost:4000/about/"
  },{
    "title": "Comment Policy",
    "excerpt":"We encourage readers to participate in the conversation by commenting on articles. With the intent of creating an open and welcoming community, there are some rules and guidelines that need to be followed when commenting.   Any infringement of this rules will lead to deletion of the comment and blocking of the comment’s author.      Be respectful: Do not use profane language or insults of any type.   Stay on-topic: Comments should relate to the post’s content.   No Self Promotion: Do not promote products or websites unless it is contextually adequate  (for example for helping someone with a problem or to answer a question).   No spam: Only comment if you think you can provide positive and insightful information or encouragement. Space-filling-only comments (for example “Hello”) will be deleted.   You are responsible for the information you provide: Comments are publicly visible and available to anyone on the Internet. It is not recommended to provide any kind of personal information (information that is not available on the Internet, on social media or similar, about you or others).   Do not take the information provided in the comments literally: If you decide to follow other commentator’s advice, any actions taken will be your responsibility. So make sure you know what you are doing!   Use appropriate language: Keep it family-friendly.   By commenting, you agree to these guidelines. Comments violating this policy may be removed.   Thank you for helping maintain a positive space for discussion!  ","url": "http://localhost:4000/comment-policy/"
  },{
    "title": "DSA",
    "excerpt":"   Interesting data structure concepts   ","url": "http://localhost:4000/data-structures/"
  },{
    "title": "Full Stack Development",
    "excerpt":" ","url": "http://localhost:4000/full-stack/"
  },{
    "title": "Misc",
    "excerpt":">Ponderings about unrelated stuff","url": "http://localhost:4000/miscellaneous/"
  },{
    "title": "Networks",
    "excerpt":">Interesting networks concepts","url": "http://localhost:4000/networking/"
  },{
    "title": "Operating Systems",
    "excerpt":">Cool operating systems stuff","url": "http://localhost:4000/operating-systems/"
  },{
    "title": "Tech Views",
    "excerpt":">My Tech Insights","url": "http://localhost:4000/tech-views/"
  },{
    "title": "networks",
    "excerpt":"","url": "http://localhost:4000/tags/networks/"
  },{
    "title": "DNS",
    "excerpt":"","url": "http://localhost:4000/tags/dns/"
  },{
    "title": "os",
    "excerpt":"","url": "http://localhost:4000/tags/os/"
  },{
    "title": "fork",
    "excerpt":"","url": "http://localhost:4000/tags/fork/"
  },{
    "title": "process creation",
    "excerpt":"","url": "http://localhost:4000/tags/process-creation/"
  },{
    "title": "bugs",
    "excerpt":"","url": "http://localhost:4000/tags/bugs/"
  },{
    "title": "debugging",
    "excerpt":"","url": "http://localhost:4000/tags/debugging/"
  },{
    "title": "installation",
    "excerpt":"","url": "http://localhost:4000/tags/installation/"
  },{
    "title": "flask",
    "excerpt":"","url": "http://localhost:4000/tags/flask/"
  },{
    "title": "tls",
    "excerpt":"","url": "http://localhost:4000/tags/tls/"
  },{
    "title": "security",
    "excerpt":"","url": "http://localhost:4000/tags/security/"
  },{
    "title": "tcp/ip",
    "excerpt":"","url": "http://localhost:4000/tags/tcp-ip/"
  },{
    "title": "node js",
    "excerpt":"","url": "http://localhost:4000/tags/node-js/"
  },{
    "title": "react",
    "excerpt":"","url": "http://localhost:4000/tags/react/"
  },{
    "title": "web app",
    "excerpt":"","url": "http://localhost:4000/tags/web-app/"
  },{
    "title": "security headers",
    "excerpt":"","url": "http://localhost:4000/tags/security-headers/"
  },{
    "title": "helmet",
    "excerpt":"","url": "http://localhost:4000/tags/helmet/"
  },{
    "title": "production",
    "excerpt":"","url": "http://localhost:4000/tags/production/"
  },{
    "title": "time",
    "excerpt":"","url": "http://localhost:4000/tags/time/"
  },{
    "title": "minute",
    "excerpt":"","url": "http://localhost:4000/tags/minute/"
  },{
    "title": "networking",
    "excerpt":"","url": "http://localhost:4000/categories/networking/"
  },{
    "title": "operating systems",
    "excerpt":"","url": "http://localhost:4000/categories/operating-systems/"
  },{
    "title": "tech-views",
    "excerpt":"","url": "http://localhost:4000/categories/tech-views/"
  },{
    "title": "full-stack",
    "excerpt":"","url": "http://localhost:4000/categories/full-stack/"
  },{
    "title": "miscellaneous",
    "excerpt":"","url": "http://localhost:4000/categories/miscellaneous/"
  }]
