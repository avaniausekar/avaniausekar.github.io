var store = [{
        "title": "Secret Life of A DNS Query",
        "excerpt":"This article describes how a DNS query gets resolved. Though a website is loaded in just one-click on our devices, a lot of work goes on at the back end to render that webpage. Let’s see how it’s done.   Before you read further, these are the terms you need to get acquainted with:  Important Terms:   IP Address   An IP address is a unique address that identifies a device on the internet or a local network.   Query   A query is a message sent by the client to the server.   Cache   Computing component that transparently stores data so that future requests for that data can be served faster.   DNS - the Internet’s Directory Service   The browser needs to translate “www.blogger.com” to its corresponding IP address, because hostnames can consist of variable-length alphanumeric characters, they would be difficult to process by routers. For these reasons, hosts are also identified by so-called IP addresses.   DNS Resolver   Servers designed to receive DNS queries from web browsers and other applications.   Authoritative Name Servers   Servers where the DNS records are stored. Consists of root name servers, TLD servers and authoritative servers.      Interaction of DNS Servers:     Consider you click on the URL www.blogger.com           Browser first checks if IP address is present in its DNS cache, if not it calls the function present in the operating system to do DNS lookups. For E.g. on Linux that function is getaddrinfo.            The OS might also have a DNS cache, if it has, then the function first checks if IP address is present in this cache. If IP is still not found, the function sends request to a server called DNS resolver            The resolver checks if IP address is present in its cache, if not it contacts the root name server.            The root name server checks if IP is present in its cache, if yes, it sends the corresponding IP address, if not it replies with “I don’t know this name but ask the TLD server.”            The resolver then asks/queries the TLD server.            The TLD server checks if IP is present in its cache, if yes, it sends the corresponding IP address, if not it replies with “I don’t know this name but ask the Authoritative name server.”            The resolver then queries the authoritative name server.            The authoritative name server has the IP Address of the requested website in its database. It responds with the corresponding IP to the resolver.            The resolver/local DNS server then sends this IP to the OS.            This IP is communicated to the browser and it starts opening a TCP connection to the server.       As shown above, the DNS query is iterative in nature, as recursive queries put heavy load of name resolution in upper levels of hierarchy.    References:   James Kurose, Keith Ross, Computer Networking A Top-Down Approach, 7th Edition.  ","categories": ["networking"],
        "tags": ["networking"],
        "url": "/networking/secret-life-of-a-dns-query/",
        "teaser": null
      },{
        "title": "Creating Processes",
        "excerpt":"In this article I have tried to explain the important things that happen during a process creation. I always had doubts about     How a process is created in OS ?   From where does it all start ?   What happens when you start a process ?   What exactly is fork and exec ?   Let us see.   Process Heirarchy   Every process in Linux lives in a “process tree”. You can see that tree by running pstree in terminal. The root of the tree is init, with PID 1. Every process (except init) has a parent, and any process has many children.   Fork() System Call   The fork() system call is used to create a new process.The new process created by fork is called the child process.This function is called once but returns twice. The only difference in the returns is that the return value in the child is 0, whereas the return value in the parent is the process ID of the new child.The child - the process that is created is an (almost) exact copy of the calling process.   Exec() System Call  (Load into memory and then execute)   Fork creates a new process which is a clone of itself, but what if we want to change the course of the process? Then we use exec() syscall. Exec() replaces the current process — its text, data, heap, and stack segments — with a brand-new program from disk.   On Boot Up   On boot the kernel starts the init process, which then forks and execs the systems boot scripts. These fork and exec more programs, eventually ending up forking a login process.This is also known as process spawning which is carried out by these two systemcalls [fork &amp; exec] in the background.     Example code snippet of fork() and exec() in a C program:   int pid = fork(); // now I am split in two! aaaaugh! // who am I? I could be either the child or the parent if (pid == 0) {     // ok I am the child process     // ls will take over and I will be a totally different process      exec([\"ls\"]) } else if (pid == -1) {     // omg fork failed -- this is a disaster :( } else {     // ok i am the parent     // continue my business being a cool program     // I could wait for the child to finish if I want }    Now, if I want to start a process called ls to list all the files in a directory. The process starts out like this:   my parent      |- me   When I run fork(), a child is created which is a clone of myself.   my parent      |- me           |-- clone of me  Then my clone calls exec() that is, my child runs exec(\"ls\"). That leaves us with   my parent      |- me           |-- ls  Once ls exits I will be all alone by myself.(Almost)   my parent      |- me           |-- ls(zombie)  At this point ls is actually a zombie process! That means it’s dead, but it’s waiting around for the parent in case the parent wants to check on its (child’s) return value (using the wait system call.) Once I get its return value, I will really be all alone again.   my parent      |- me     The following paragraph from Operating Systems:Three Easy Pieces sums up the gist of the article:      The fork() system call is strange; its partner in crime, exec(), is not so normal either. What it does: given the name of an executable (e.g., wc), and some arguments (e.g., p3.c), it loads code (and static data) from that executable and overwrites its current code segment (and current static data) with it; the heap and stack and other parts of the memory space of the program are re-initialized. Then the OS simply runs that program, passing in any arguments as the argv of that process. Thus, it does not create a new process; rather, it transforms the currently running program (formerly p3) into a different running program (wc). After the exec() in the child, it is almost as if p3.c never ran; a successful call to exec() never returns.      References:   Remzi H. Arpaci-Dusseau_ Andrea C Arpaci-Dusseau - Operating Systems- Three Easy Pieces   Got this awesome concept from Julia Evans blog  ","categories": ["operating systems"],
        "tags": ["os"],
        "url": "/operating%20systems/process-creation/",
        "teaser": null
      },{
        "title": "Debugging 101 - Love Your Bugs",
        "excerpt":"Errors and bugs are a necessary evil in any software developement field, and learning the art of debugging is a very vital step if you want to:      Improve your developer productivity   Write reliable code   In this article I have tried to document all the debugging methods that I learnt while working on my projects.      Whenever you encounter a bug in any of your code/installation it is always helpful to remember the following things:     The error happens for a logical reason - its never magic   Be confident that you can fix it   Being stuck is temporary   Now that you have these 3 things in your toolkit let us proceed for some debugging steps so that you can feel your inherent superpower. :)   Step 1: Read error message carefully   Error messages usually contain a lot of information about what went wrong. But they sometimes can be very large and overwhelming to read. You can  use these tricks to extract the necessary information from them:     Start fixing the first error message in case of multiple error messages. Fixing the first one often fixes the remaining errors   Search if any solution is available on the internet for the error   Step 2: Brainstorm possible reasons for the error   Now here I won’t be able to give exact reasons but some examples may include:     Is there something wrong with the server?   Am I using correct package version?   Have I followed all the instructions?(In case of errors in installations)   After finding possible reasons try to narrow it down to the most possible reason, also draw a diagram of the process if possible   Step 3: Investigate      Read the documentation (Important)   Add lots of print statements   Use a debugger   Look at logs   A meme that highlights the importance of reading the docs:      Step 4: Make complex things simple      Fix one problem at a time   Write clean code   Reduce randomness   Shorten your feedback/output loop (when you need to run the code many times)   Step 5: This also helps      Take a break   Ask a friend   Explain the error/bug out loud   Finding tools that make debugging easier - eg. debuggers, profilers, tracers, fuzzers, etc   Step 6: After fixing the bug     Celebrate - dance a little   Tell somebody what you learnt - that way you won’t forget it   Document your bug    Debugging can be an interesting adventure.   I would like to end this article by quoting Edsger Dijkstra:     ” Program testing can be used to show the presence of bugs, but never to show their absence! “   ","categories": ["tech-insights"],
        "tags": [],
        "url": "/tech-insights/debugging_guide/",
        "teaser": null
      },{
        "title": "Deploy a Python Server with Flask on Windows Apache Server",
        "excerpt":"Recently I programmed a TLS/SSL checker web app - which checks which tls protocol a website is using and also gives a list of SSL vulnerablities the website is prone to. I programmed this script in python using flask framework and now I wanted to deploy it to the server. But little did I know that deploying or setting up a python server with flask can be tricky especially on a apache server.   So, these are my learnings and some useful links - you can read them so that you can finish deploying a python server on Windows apache faster than me ! :)   Prerequisites:     Python - can be downloaded from https://www.python.org/downloads/   Flask - can be installed by typing the following command in cmd  pip install flask   WfastCGI module - installed by typing the following command in cmd pip install wfastcgi     Deploying using Windows IIS Server:           I have used this link to install until step IV with some changes. CGI module will be found in  Server Roles &gt; Web Server(IIS) &gt; Web Server &gt; Application Development &gt; CGI (If not found at the exact location as given in article) article link            If after all steps – if you get internal server error when you access the website url - you can refer these steps: reference Error an unknown FastCGI error occurred             To deploy it on port 4000:             Go to IIS Manager       In sites dropdown select the TLS checker website       Select Edit site&gt;Bindings       Select https &gt; edit &gt;       Enter port 4000       Add hostname       You may have to open the port 4000 in inbound firewall rules               Deploying using WAMP Server :      This article is very apt but I might go into more details about this installation in coming weeks. https://thilinamad.medium.com/flask-app-deployment-in-windows-apache-server-mod-wsgi-82e1cfeeb2ed      Thank - You for reading !         Avani       ","categories": ["tech-insights"],
        "tags": [],
        "url": "/tech-insights/Ways-to-deploy-a-python-server-on-apache/",
        "teaser": null
      },{
    "title": "About",
    "excerpt":"   Intelligence is the ability to avoid doing work, yet getting the work done.    Hello ! I am Avani, a curious Information Technology student with a keen interest in fascinating tech concepts. My plan is to upload all the interesting things I discover here, including my projects, explanations of various concepts, and helpful installation guides. I’m also looking to collaborate on open-source projects, so feel free to connect with me!   I invite you to dive into a vibrant collection of the most intriguing tech projects, ideas, and experiments from the world of software development and beyond. This blog is a sandbox for the curious and creative — whether you’re a developer seeking inspiration, a tech enthusiast exploring trends, or just someone fascinated by the intersection of code and creativity.   Thank you for visiting my website.  ","url": "http://localhost:4000/about/"
  },{
    "title": "Comment Policy",
    "excerpt":"We encourage readers to participate in the conversation by commenting on articles. With the intent of creating an open and welcoming community, there are some rules and guidelines that need to be followed when commenting.   Any infringement of this rules will lead to deletion of the comment and blocking of the comment’s author.      Be respectful: Do not use profane language or insults of any type.   Stay on-topic: Comments should relate to the post’s content.   No Self Promotion: Do not promote products or websites unless it is contextually adequate  (for example for helping someone with a problem or to answer a question).   No spam: Only comment if you think you can provide positive and insightful information or encouragement. Space-filling-only comments (for example “Hello”) will be deleted.   You are responsible for the information you provide: Comments are publicly visible and available to anyone on the Internet. It is not recommended to provide any kind of personal information (information that is not available on the Internet, on social media or similar, about you or others).   Do not take the information provided in the comments literally: If you decide to follow other commentator’s advice, any actions taken will be your responsibility. So make sure you know what you are doing!   Use appropriate language: Keep it family-friendly.   By commenting, you agree to these guidelines. Comments violating this policy may be removed.   Thank you for helping maintain a positive space for discussion!  ","url": "http://localhost:4000/comment-policy/"
  },{
    "title": "DSA",
    "excerpt":"   Interesting data structure concepts   ","url": "http://localhost:4000/data-structures/"
  },{
    "title": "Full Stack Development",
    "excerpt":" ","url": "http://localhost:4000/full-stack/"
  },{
    "title": "Networking",
    "excerpt":">Interesting networks concepts","url": "http://localhost:4000/networking/"
  },{
    "title": "Operating Systems",
    "excerpt":">Cool operating systems stuff","url": "http://localhost:4000/operating-systems/"
  },{
    "title": "Tech Insights",
    "excerpt":">My Tech Insights","url": "http://localhost:4000/tech-insights/"
  },{
    "title": "networking",
    "excerpt":"","url": "http://localhost:4000/tags/networking/"
  },{
    "title": "os",
    "excerpt":"","url": "http://localhost:4000/tags/os/"
  },{
    "title": "networking",
    "excerpt":"","url": "http://localhost:4000/categories/networking/"
  },{
    "title": "operating systems",
    "excerpt":"","url": "http://localhost:4000/categories/operating-systems/"
  },{
    "title": "tech-insights",
    "excerpt":"","url": "http://localhost:4000/categories/tech-insights/"
  }]
