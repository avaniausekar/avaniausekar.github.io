---
layout: single
title:  "Easiest Implementation of the Travelling Salesman Problem"
date:   2025-01-03 09:30:45 +0530
categories: 
        - not live yet
tags: 
        - data structures
        - tsp
        - python
toc: true
---

```python
def checkbound(st,des,cost,t):
    n = len(cost[0])
    pencost = t
    #copy cost in reduced matrix
    reduced = [row[:] for row in cost]
    #assign infinity
    for j in range(n):
        reduced[st][j] = float('inf')
    for i in range(n):
        reduced[i][des] = float('inf')

    reduced[des][0] = float('inf')
    #addition of subtracted row,col -->(rs ,cs)
    reduced,row = rowReduction(reduced)
    reduced,col = colReduction(reduced)

    pencost = pencost + row + col + cost[st][des]
    return reduced,pencost


def rowMinVal(cost,i):
    n = len(cost[0])
    minVal = cost[i][0]
    for  j in range(n):
        if cost[i][j] < minVal:
            minVal = cost[i][j]

    return minVal

def colMinVal(cost,i):
    n = len(cost[0])
    minVal = cost[0][i]
    for j in range(n):
        if cost[j][i] < minVal:
            minVal = cost[j][i]
    return minVal

def rowReduction(cost):
    row = 0
    n = len(cost[0])
    for i in range(n):
        rmin = rowMinVal(cost,i)
        #print(rmin , i)
        if rmin != float('inf'):
            row += rmin
        for j in range(n):
            if cost[i][j] != float('inf'):
                cost[i][j] -= rmin
    return cost,row

def colReduction(cost):
    col = 0
    n = len(cost[0])
    for j in range(n):
        cmin = colMinVal(cost,j)
        if cmin != float('inf'):
            col += cmin
        for i in range(n):
            if cost[i][j] != float('inf'):
                cost[i][j] -= cmin
    return cost,col

def all_visited(select):
    return all(select)
    
def main():
    matrix = [
            [float('inf'),4,2],
            [3,float('inf'),4],
            [1,8,float('inf')]
    ]
    matrix,row = rowReduction(matrix)
    #print(matrix)
    matrix,col = colReduction(matrix)
    t = row + col
    print("Starting cost ",t)
    print("First reduced matrix rcm")
    for m in matrix:
        print(m)

    k = 0
    n = len(matrix[0])
    select = [0] *n
    path = []
    path.append(k) 
    nextmatrix = matrix
    while not all_visited(select):
        matrix = nextmatrix
        #matries to store matrices
        #val list to take the least cost of each pathe then take corres matrices
        matrices = [0] * n
        val_list = [0] * n
        val_list[0] = float('inf')
        print("K value ",k)

        for i in range(1,n):
            #route not explored
            if select[i] == 0:
                tempmatrix,tempcost = checkbound(k,i,matrix,t)
                matrices[i] = tempmatrix
                val_list[i] = tempcost
            else:
                # we do not want to consider the 0 in finding min
                val_list[i] = float('inf')

        min_val = min(val_list)
        k = val_list.index(min_val)
        nextmatrix = matrices[k]
        t = min_val
        select[k] = 1
        path.append(k)
        print("min val ",min_val)
        print("Next matrix",nextmatrix)

    print("Final path ",path)
    
main()

```